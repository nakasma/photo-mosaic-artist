<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Mosaic Artist - 高精度フォトモザイク生成</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Google Fonts: Added Teko -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&family=Teko:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Noto Sans JP"', 'sans-serif'],
                        teko: ['"Teko"', 'sans-serif'], // Added Teko font
                    },
                    colors: {
                        primary: {
                            50: '#f0f9ff',
                            100: '#e0f2fe',
                            500: '#0ea5e9',
                            600: '#0284c7',
                            700: '#0369a1',
                        },
                    }
                }
            }
        }
    </script>
    <style>
        body { background-color: #f8fafc; color: #1e293b; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        .step-card { transition: all 0.3s ease; }
        .step-card:hover { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }
        
        .canvas-bg {
            background-image: 
                linear-gradient(45deg, #e2e8f0 25%, transparent 25%), 
                linear-gradient(-45deg, #e2e8f0 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #e2e8f0 75%), 
                linear-gradient(-45deg, transparent 75%, #e2e8f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #0ea5e9;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Zoom specific styles */
        #canvasViewport {
            touch-action: none; /* Disable default browser touch actions (scrolling) inside the canvas area */
            cursor: grab;
        }
        #canvasViewport:active {
            cursor: grabbing;
        }

        /* --- Rainbow Button Styles --- */
        .btn-rainbow {
            background: linear-gradient(
                45deg,
                #ff4b1f, /* Red-Orange */
                #ff9068, /* Orange-Pink */
                #ffcc33, /* Yellow */
                #00b09b, /* Green */
                #96c93d, /* Light Green */
                #005bea, /* Blue */
                #764ba2, /* Purple */
                #ff4b1f  /* Red-Orange loop */
            );
            background-size: 300% 300%;
            animation: rainbow-move 4s ease infinite;
            border: none;
        }
        @keyframes rainbow-move {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .btn-rainbow:disabled {
            background: #e2e8f0 !important; /* gray-200 */
            color: #94a3b8 !important; /* gray-400 */
            animation: none !important;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-white/90 backdrop-blur-md shadow-sm sticky top-0 z-50 border-b border-gray-100">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-between">
            <div class="flex items-center gap-3 group cursor-pointer" onclick="location.reload()">
                <!-- Artistic Mosaic Icon -->
                <div class="w-10 h-10 grid grid-cols-3 gap-0.5 rounded-lg overflow-hidden shadow-sm group-hover:shadow-md transition-all group-hover:rotate-3 flex-shrink-0">
                    <div class="bg-rose-500"></div><div class="bg-orange-500"></div><div class="bg-amber-500"></div>
                    <div class="bg-emerald-500"></div><div class="bg-cyan-500"></div><div class="bg-blue-500"></div>
                    <div class="bg-indigo-500"></div><div class="bg-violet-500"></div><div class="bg-fuchsia-500"></div>
                </div>
                
                <!-- Artistic Title (Teko Font, Mosaic Coloring) -->
                <h1 class="font-teko text-3xl sm:text-4xl font-medium tracking-wide leading-none flex items-baseline gap-1.5 select-none transform translate-y-0.5">
                    <!-- PHOTO: Warm Tones -->
                    <div class="flex">
                        <span class="text-rose-500">P</span>
                        <span class="text-orange-500">H</span>
                        <span class="text-amber-500">O</span>
                        <span class="text-yellow-500">T</span>
                        <span class="text-lime-500">O</span>
                    </div>
                    <!-- MOSAIC: Cool Tones -->
                    <div class="flex">
                        <span class="text-emerald-500">M</span>
                        <span class="text-teal-500">O</span>
                        <span class="text-cyan-500">S</span>
                        <span class="text-sky-500">A</span>
                        <span class="text-blue-500">I</span>
                        <span class="text-indigo-500">C</span>
                    </div>
                    <!-- ARTIST: Purple/Mix Tones -->
                    <div class="flex">
                        <span class="text-violet-500">A</span>
                        <span class="text-purple-500">R</span>
                        <span class="text-fuchsia-500">T</span>
                        <span class="text-pink-500">I</span>
                        <span class="text-rose-400">S</span>
                        <span class="text-red-500">T</span>
                    </div>
                </h1>
            </div>
            
            <!-- Removed CIELAB Matching Engine badge -->
            <div></div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 w-full">
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            
            <!-- Settings Panel -->
            <div class="lg:col-span-4 space-y-6">
                
                <!-- 1. Main Image (Full Card Dropzone) -->
                <div id="mainStepCard" class="bg-white rounded-2xl p-6 shadow-sm border border-gray-100 step-card relative overflow-hidden transition-colors">
                    
                    <!-- Drag Overlay (Step 1) -->
                    <div id="mainDragOverlay" class="absolute inset-0 bg-primary-50/95 z-50 hidden flex-col items-center justify-center backdrop-blur-sm border-2 border-primary-500 border-dashed rounded-2xl pointer-events-none">
                        <!-- Restored Original Icon -->
                        <i data-lucide="image-plus" class="w-12 h-12 text-primary-600 mb-3"></i>
                        <p class="text-lg font-bold text-primary-700">メイン写真を変更</p>
                        <p class="text-sm text-primary-600 mt-1">ここにドロップして更新</p>
                    </div>

                    <div class="flex items-center gap-3 mb-4">
                        <!-- Step 1: Red/Orange Gradient Square -->
                        <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-rose-400 to-orange-400 flex items-center justify-center text-white font-bold shadow-sm">1</div>
                        <h2 class="text-lg font-bold text-gray-800">メイン写真</h2>
                    </div>
                    
                    <div class="relative group">
                        <input type="file" id="mainImageInput" accept="image/*" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
                        <div id="mainImageDropzone" class="border-2 border-dashed border-gray-300 rounded-xl p-6 flex flex-col items-center justify-center text-center transition-colors group-hover:border-primary-500 bg-gray-50 group-hover:bg-primary-50 h-48 relative overflow-hidden">
                            <div id="dropzoneContent" class="flex flex-col items-center">
                                <!-- Restored Original Icon -->
                                <i data-lucide="image-plus" class="w-10 h-10 text-gray-400 mb-2 group-hover:text-primary-500"></i>
                                <p class="text-sm font-medium text-gray-600">メイン写真をドロップ</p>
                            </div>
                            <img id="mainImagePreview" class="hidden absolute inset-0 w-full h-full object-cover pointer-events-none" />
                        </div>
                    </div>
                </div>

                <!-- 2. Tile Images (Full Card Dropzone + Loading Overlay) -->
                <div id="tileStepCard" class="bg-white rounded-2xl p-6 shadow-sm border border-gray-100 step-card relative overflow-hidden transition-colors">
                    
                    <!-- Drag Overlay (Step 2) -->
                    <div id="tileDragOverlay" class="absolute inset-0 bg-primary-50/95 z-50 hidden flex-col items-center justify-center backdrop-blur-sm border-2 border-primary-500 border-dashed rounded-2xl pointer-events-none">
                        <i data-lucide="copy-plus" class="w-12 h-12 text-primary-600 mb-3"></i>
                        <p class="text-lg font-bold text-primary-700">画像をここに追加</p>
                        <p class="text-sm text-primary-600 mt-1">フレーム内のどこでもOK</p>
                    </div>

                    <!-- Tile Loading Overlay -->
                    <div id="tileLoadingOverlay" class="absolute inset-0 bg-white/90 z-40 hidden flex-col items-center justify-center backdrop-blur-sm rounded-2xl transition-opacity">
                        <div class="loader w-8 h-8 border-primary-500 border-t-transparent mb-3"></div>
                        <p class="text-sm font-bold text-primary-700 animate-pulse">画像を解析中...</p>
                        <p id="tileLoadingProgress" class="text-xs text-primary-600 font-mono mt-1">0%</p>
                    </div>

                    <div class="flex items-center gap-3 mb-4">
                        <!-- Step 2: Blue/Cyan Gradient Square -->
                        <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-blue-400 to-cyan-400 flex items-center justify-center text-white font-bold shadow-sm">2</div>
                        <h2 class="text-lg font-bold text-gray-800">ピース写真</h2>
                    </div>

                    <div class="relative group mb-4">
                        <input type="file" id="tileImagesInput" accept="image/*" multiple class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
                        <div class="border-2 border-dashed border-gray-300 rounded-xl h-32 flex flex-col items-center justify-center gap-3 text-center transition-colors group-hover:border-primary-500 bg-gray-50 group-hover:bg-primary-50">
                            <!-- Icon removed -->
                            <span class="text-sm font-medium text-gray-600">ピース写真をドロップ</span>
                        </div>
                    </div>
                    
                    <div class="flex justify-between items-center text-sm text-gray-600 mb-2">
                        <span>解析済み: <span id="tileCount" class="font-bold text-primary-600">0</span> 枚</span>
                        <button id="clearTilesBtn" class="text-xs text-red-500 hover:text-red-700 hidden">クリア</button>
                    </div>
                    
                    <div id="tilePreviewContainer" class="flex gap-2 overflow-x-auto pb-2 h-16 empty:hidden scrollbar-hide">
                        <!-- Thumbnails injected here -->
                    </div>
                </div>

                <!-- 3. Generation Settings -->
                <div class="bg-white rounded-2xl p-6 shadow-sm border border-gray-100 step-card">
                    <div class="flex items-center gap-3 mb-4">
                        <!-- Step 3: Purple/Pink Gradient Square -->
                        <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-violet-400 to-fuchsia-400 flex items-center justify-center text-white font-bold shadow-sm">3</div>
                        <h2 class="text-lg font-bold text-gray-800">生成設定</h2>
                    </div>

                    <div class="space-y-5">
                        <!-- Resolution -->
                        <div>
                            <label class="flex justify-between text-sm font-medium text-gray-700 mb-1">
                                モザイクの密度
                                <span class="text-primary-600 text-xs font-bold" id="resolutionValue">中 (80x)</span>
                            </label>
                            <input type="range" id="resolutionRange" min="20" max="120" value="80" step="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary-600">
                        </div>

                        <!-- Blend -->
                        <div>
                            <label class="flex justify-between text-sm font-medium text-gray-700 mb-1">
                                元画像のブレンド率
                                <span class="text-primary-600 text-xs font-bold" id="blendValue">10%</span>
                            </label>
                            <input type="range" id="blendRange" min="0" max="80" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary-600">
                        </div>

                        <!-- Advanced Toggles -->
                        <div class="bg-gray-50 p-3 rounded-lg space-y-3">
                            <!-- Removed Diversity Checkbox (Always On) -->

                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="checkbox" id="colorCorrectCheck" checked class="w-4 h-4 text-primary-600 rounded border-gray-300 focus:ring-primary-500">
                                <span class="text-sm text-gray-700 font-medium">色調の自動微調整</span>
                            </label>
                        </div>
                        
                        <!-- Updated Generate Button with Rainbow UI -->
                        <button id="generateBtn" disabled class="btn-rainbow w-full text-white font-bold py-4 px-6 rounded-xl shadow-lg hover:shadow-2xl transform hover:-translate-y-1 transition-all duration-300 flex items-center justify-center gap-3 mt-4 group relative overflow-hidden">
                            <!-- Shine Effect -->
                            <div class="absolute inset-0 bg-white/20 translate-x-[-100%] skew-x-[-15deg] group-hover:translate-x-[100%] transition-transform duration-700 ease-in-out"></div>
                            
                            <!-- Icon removed -->
                            <span id="btnText" class="relative z-10 text-xl tracking-wider drop-shadow-sm font-teko">モザイクアート生成</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Result Panel (Fixed Height Layout) -->
            <div class="lg:col-span-8 flex flex-col gap-4 lg:h-[calc(100vh-8rem)] lg:sticky lg:top-24">
                <!-- Header with Download Button -->
                <div class="bg-white rounded-2xl shadow-sm border border-gray-100 p-3 flex items-center justify-between px-4 flex-shrink-0">
                    <span class="text-base font-bold text-gray-700 flex items-center gap-2">
                        <i data-lucide="monitor" class="w-5 h-5"></i> プレビュー
                    </span>
                    
                    <div class="flex items-center gap-3">
                        <span id="statusMessage" class="text-xs text-gray-500 hidden sm:flex items-center gap-2"></span>
                        <button id="downloadBtn" disabled class="bg-gray-800 hover:bg-gray-900 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-lg shadow transition-all flex items-center gap-2 text-sm">
                            <i data-lucide="download" class="w-4 h-4"></i>
                            <span class="whitespace-nowrap">高画質で保存</span>
                        </button>
                    </div>
                </div>

                <!-- Canvas Container (Responsive Height) -->
                <div class="bg-white rounded-2xl shadow-lg border border-gray-200 overflow-hidden flex-grow flex flex-col relative min-h-[500px] lg:min-h-0 h-full">
                    
                    <!-- Viewport: Clips the overflow. Changed from items-center to items-start + padding top to show image at top -->
                    <div id="canvasViewport" class="relative w-full h-full overflow-hidden canvas-bg flex items-start justify-center pt-10">
                        <!-- Transform Target: Scales and moves -->
                        <div id="canvasTransform" class="transition-transform duration-75 ease-out origin-center">
                            <!-- Canvas itself (no max-width constraint to allow zoom) -->
                            <canvas id="mosaicCanvas" class="shadow-2xl hidden"></canvas>
                        </div>

                        <!-- Empty State -->
                        <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center text-center p-8 pointer-events-none">
                            <div class="bg-blue-50 w-24 h-24 rounded-full flex items-center justify-center mx-auto mb-6 animate-pulse">
                                <i data-lucide="palette" class="w-12 h-12 text-primary-300"></i>
                            </div>
                            <h3 class="text-lg font-bold text-gray-900 mb-2">準備完了</h3>
                            <p class="text-gray-500 text-sm max-w-sm mx-auto leading-relaxed">
                                左のパネルから画像をアップロードしてください。<br>
                                CIELAB色空間アルゴリズムを使用して<br>高精度なモザイクアートを生成します。
                            </p>
                        </div>

                        <!-- Loading Overlay (Main Canvas) -->
                        <div id="loadingOverlay" class="absolute inset-0 bg-white/90 backdrop-blur-sm z-20 hidden flex-col items-center justify-center">
                            <div class="loader mb-4 w-10 h-10 border-4"></div>
                            <p id="loadingText" class="text-primary-700 font-bold text-lg animate-pulse mb-1">処理中...</p>
                            <p id="loadingSubText" class="text-gray-500 text-xs mb-6">最適な配置を計算しています</p>
                            
                            <div class="w-72 h-3 bg-gray-100 rounded-full overflow-hidden border border-gray-200">
                                <div id="progressBar" class="h-full bg-gradient-to-r from-primary-400 to-primary-600 w-0 transition-all duration-300 ease-out"></div>
                            </div>
                            <p id="progressText" class="text-xs text-gray-400 mt-2 font-mono">0%</p>
                        </div>
                    </div>

                    <!-- Zoom Controls (Visible when canvas is shown) -->
                    <div id="zoomControls" class="absolute bottom-6 right-6 flex flex-col gap-3 z-10 hidden">
                        <button id="zoomInBtn" class="bg-white/90 backdrop-blur-sm text-gray-700 p-3 rounded-full shadow-lg border border-gray-200 hover:bg-gray-50 active:bg-gray-100 transition-all transform hover:scale-105" title="ズームイン">
                            <i data-lucide="plus" class="w-6 h-6"></i>
                        </button>
                        <button id="zoomResetBtn" class="bg-white/90 backdrop-blur-sm text-gray-700 p-3 rounded-full shadow-lg border border-gray-200 hover:bg-gray-50 active:bg-gray-100 transition-all transform hover:scale-105" title="全体表示">
                            <i data-lucide="maximize" class="w-6 h-6"></i>
                        </button>
                        <button id="zoomOutBtn" class="bg-white/90 backdrop-blur-sm text-gray-700 p-3 rounded-full shadow-lg border border-gray-200 hover:bg-gray-50 active:bg-gray-100 transition-all transform hover:scale-105" title="ズームアウト">
                            <i data-lucide="minus" class="w-6 h-6"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="bg-white border-t border-gray-100 mt-auto">
        <div class="max-w-7xl mx-auto px-4 py-6 text-center text-sm text-gray-500">
            Photo Mosaic Artist - Powered by CIELAB Color Engine
        </div>
    </footer>

    <!-- Logic -->
    <script>
        lucide.createIcons();

        // --- Color Science Utilities (CIELAB) ---
        const ColorUtils = {
            // Convert RGB (0-255) to XYZ
            rgbToXyz: (r, g, b) => {
                let _r = r / 255, _g = g / 255, _b = b / 255;
                _r = _r > 0.04045 ? Math.pow((_r + 0.055) / 1.055, 2.4) : _r / 12.92;
                _g = _g > 0.04045 ? Math.pow((_g + 0.055) / 1.055, 2.4) : _g / 12.92;
                _b = _b > 0.04045 ? Math.pow((_b + 0.055) / 1.055, 2.4) : _b / 12.92;
                return {
                    x: (_r * 0.4124 + _g * 0.3576 + _b * 0.1805) * 100,
                    y: (_r * 0.2126 + _g * 0.7152 + _b * 0.0722) * 100,
                    z: (_r * 0.0193 + _g * 0.1192 + _b * 0.9505) * 100
                };
            },
            
            // Convert XYZ to CIELAB
            xyzToLab: (x, y, z) => {
                let _x = x / 95.047, _y = y / 100.000, _z = z / 108.883;
                _x = _x > 0.008856 ? Math.pow(_x, 1/3) : (7.787 * _x) + 16/116;
                _y = _y > 0.008856 ? Math.pow(_y, 1/3) : (7.787 * _y) + 16/116;
                _z = _z > 0.008856 ? Math.pow(_z, 1/3) : (7.787 * _z) + 16/116;
                return {
                    l: (116 * _y) - 16,
                    a: 500 * (_x - _y),
                    b: 200 * (_y - _z)
                };
            },

            // Wrapper: RGB to LAB
            rgbToLab: (r, g, b) => {
                const xyz = ColorUtils.rgbToXyz(r, g, b);
                return ColorUtils.xyzToLab(xyz.x, xyz.y, xyz.z);
            },

            // Calculate Distance (Euclidean in LAB space - dE76)
            deltaE: (lab1, lab2) => {
                const dl = lab1.l - lab2.l;
                const da = lab1.a - lab2.a;
                const db = lab1.b - lab2.b;
                return Math.sqrt(dl * dl * 1.5 + da * da + db * db);
            }
        };

        // --- Multi-Sampling Logic ---
        function getSmartAverageColor(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return { r:0, g:0, b:0 };
            
            const imageData = ctx.getImageData(x, y, w, h);
            const data = imageData.data;
            const len = data.length;
            
            let r = 0, g = 0, b = 0;
            let totalWeight = 0;

            const cx = w / 2;
            const cy = h / 2;
            const maxDist = Math.sqrt(cx * cx + cy * cy);

            for (let i = 0; i < len; i += 4) {
                const pxIndex = i / 4;
                const px = pxIndex % w;
                const py = Math.floor(pxIndex / w);

                const dx = px - cx;
                const dy = py - cy;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                const weight = Math.max(0.2, 1 - (dist / maxDist));
                
                r += data[i] * weight;
                g += data[i+1] * weight;
                b += data[i+2] * weight;
                totalWeight += weight;
            }

            return {
                r: Math.round(r / totalWeight),
                g: Math.round(g / totalWeight),
                b: Math.round(b / totalWeight)
            };
        }

        // --- Application State ---
        const state = {
            mainImage: null,
            tiles: [], // { id, img, lab: {l,a,b}, rgb: {r,g,b} }
            isProcessing: false,
            settings: {
                tilesX: 80,
                blend: 0.1,
                diversity: true, // Always true
                colorCorrect: true
            },
            // Zoom State
            view: {
                scale: 1,
                x: 0,
                y: 0,
                isDragging: false,
                lastX: 0,
                lastY: 0
            }
        };

        // --- DOM References ---
        const els = {
            mainInput: document.getElementById('mainImageInput'),
            mainPreview: document.getElementById('mainImagePreview'),
            dropzoneContent: document.getElementById('dropzoneContent'),
            mainDropzone: document.getElementById('mainImageDropzone'),
            mainStepCard: document.getElementById('mainStepCard'), 
            mainDragOverlay: document.getElementById('mainDragOverlay'),
            
            tileInput: document.getElementById('tileImagesInput'),
            tileStepCard: document.getElementById('tileStepCard'),
            tileDragOverlay: document.getElementById('tileDragOverlay'),
            tileLoadingOverlay: document.getElementById('tileLoadingOverlay'), 
            tileLoadingProgress: document.getElementById('tileLoadingProgress'), 
            tileCount: document.getElementById('tileCount'),
            tileContainer: document.getElementById('tilePreviewContainer'),
            clearTilesBtn: document.getElementById('clearTilesBtn'),
            
            resolutionRange: document.getElementById('resolutionRange'),
            resolutionValue: document.getElementById('resolutionValue'),
            blendRange: document.getElementById('blendRange'),
            blendValue: document.getElementById('blendValue'),
            // Removed diversityCheck
            colorCorrectCheck: document.getElementById('colorCorrectCheck'),
            
            generateBtn: document.getElementById('generateBtn'),
            downloadBtn: document.getElementById('downloadBtn'),
            
            // Zoom & Canvas elements
            canvas: document.getElementById('mosaicCanvas'),
            canvasViewport: document.getElementById('canvasViewport'),
            canvasTransform: document.getElementById('canvasTransform'),
            zoomControls: document.getElementById('zoomControls'),
            zoomInBtn: document.getElementById('zoomInBtn'),
            zoomOutBtn: document.getElementById('zoomOutBtn'),
            zoomResetBtn: document.getElementById('zoomResetBtn'),
            
            emptyState: document.getElementById('emptyState'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            loadingText: document.getElementById('loadingText'),
            loadingSubText: document.getElementById('loadingSubText'),
            progressBar: document.getElementById('progressBar'),
            progressText: document.getElementById('progressText'),
            statusMessage: document.getElementById('statusMessage'),
            // btnIcon removed
            btnText: document.getElementById('btnText')
        };

        // --- Event Listeners ---
        
        // --- GLOBAL PROTECTION ---
        window.addEventListener('dragover', (e) => e.preventDefault());
        window.addEventListener('drop', (e) => e.preventDefault());

        els.mainInput.addEventListener('change', (e) => handleMainImage(e.target.files[0]));
        
        // --- Main Image Card Drag & Drop ---
        ['dragenter', 'dragover'].forEach(evt => els.mainStepCard.addEventListener(evt, (e) => {
            e.preventDefault();
            e.stopPropagation();
            els.mainDragOverlay.classList.remove('hidden');
            els.mainDragOverlay.classList.add('flex');
        }));

        ['dragleave', 'drop'].forEach(evt => els.mainStepCard.addEventListener(evt, (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (evt === 'drop' || (e.relatedTarget && !els.mainStepCard.contains(e.relatedTarget))) {
                els.mainDragOverlay.classList.add('hidden');
                els.mainDragOverlay.classList.remove('flex');
            }
        }));
        els.mainStepCard.addEventListener('drop', (e) => {
            if(e.dataTransfer.files.length) handleMainImage(e.dataTransfer.files[0]);
        });

        // --- Tile Drag & Drop Logic ---
        els.tileInput.addEventListener('change', (e) => handleTileImages(e.target.files));
        
        ['dragenter', 'dragover'].forEach(evt => els.tileStepCard.addEventListener(evt, (e) => {
            e.preventDefault();
            e.stopPropagation();
            els.tileDragOverlay.classList.remove('hidden');
            els.tileDragOverlay.classList.add('flex');
        }));

        ['dragleave', 'drop'].forEach(evt => els.tileStepCard.addEventListener(evt, (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (evt === 'drop' || (e.relatedTarget && !els.tileStepCard.contains(e.relatedTarget))) {
                els.tileDragOverlay.classList.add('hidden');
                els.tileDragOverlay.classList.remove('flex');
            }
        }));

        els.tileStepCard.addEventListener('drop', (e) => {
            if(e.dataTransfer.files.length) handleTileImages(e.dataTransfer.files);
        });

        els.clearTilesBtn.addEventListener('click', () => { state.tiles = []; updateTileUI(); });

        els.resolutionRange.addEventListener('input', (e) => {
            state.settings.tilesX = parseInt(e.target.value);
            let label = "低";
            if(state.settings.tilesX >= 50) label = "中";
            if(state.settings.tilesX >= 90) label = "高";
            els.resolutionValue.innerText = `${label} (${state.settings.tilesX}x)`;
        });

        els.blendRange.addEventListener('input', (e) => {
            state.settings.blend = parseInt(e.target.value) / 100;
            els.blendValue.innerText = `${e.target.value}%`;
        });
        
        // Removed diversityCheck listener
        els.colorCorrectCheck.addEventListener('change', (e) => state.settings.colorCorrect = e.target.checked);

        els.generateBtn.addEventListener('click', generateMosaic);
        els.downloadBtn.addEventListener('click', downloadImage);

        // --- Zoom & Pan Event Listeners ---
        els.zoomInBtn.addEventListener('click', () => zoomCanvas(1.2));
        els.zoomOutBtn.addEventListener('click', () => zoomCanvas(0.8));
        els.zoomResetBtn.addEventListener('click', resetZoom);

        // Pan Events (Mouse)
        els.canvasViewport.addEventListener('mousedown', startPan);
        window.addEventListener('mousemove', movePan);
        window.addEventListener('mouseup', endPan);

        // Pan Events (Touch)
        els.canvasViewport.addEventListener('touchstart', (e) => {
            if(e.touches.length === 1) startPan(e.touches[0]);
        }, {passive: false});
        window.addEventListener('touchmove', (e) => {
            if(state.view.isDragging && e.touches.length === 1) {
                e.preventDefault(); // Prevent scroll while panning
                movePan(e.touches[0]);
            }
        }, {passive: false});
        window.addEventListener('touchend', endPan);

        // Wheel Zoom (Desktop)
        els.canvasViewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY < 0 ? 1.1 : 0.9;
            zoomCanvas(factor);
        }, {passive: false});

        // --- Handlers ---

        function handleMainImage(file) {
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    state.mainImage = img;
                    els.mainPreview.src = e.target.result;
                    els.mainPreview.classList.remove('hidden');
                    els.dropzoneContent.style.opacity = '0';
                    checkReady();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function handleTileImages(files) {
            if (!files.length) return;
            
            // Show Card Overlay
            els.tileLoadingOverlay.classList.remove('hidden');
            els.tileLoadingOverlay.classList.add('flex');
            els.tileDragOverlay.classList.add('hidden'); // Ensure drag overlay is gone
            
            setLoading(true, "画像の解析中...", "色空間(CIELAB)へ変換しています");
            
            const fileList = Array.from(files);
            let processed = 0;
            const chunkSize = 5;

            const anaCanvas = document.createElement('canvas');
            const anaCtx = anaCanvas.getContext('2d');
            anaCanvas.width = 50; 
            anaCanvas.height = 50;

            try {
                for (let i = 0; i < fileList.length; i += chunkSize) {
                    const chunk = fileList.slice(i, i + chunkSize);
                    await Promise.all(chunk.map(file => processTile(file, anaCanvas, anaCtx)));
                    
                    processed += chunk.length;
                    const pct = (processed / fileList.length) * 100;
                    updateProgress(pct);
                    // Update card progress text
                    els.tileLoadingProgress.innerText = `${Math.round(pct)}%`;
                    
                    await new Promise(r => setTimeout(r, 0)); // Yield
                }
            } finally {
                // Hide Card Overlay when done (or error)
                els.tileLoadingOverlay.classList.add('hidden');
                els.tileLoadingOverlay.classList.remove('flex');
                
                setLoading(false);
                updateTileUI();
                checkReady();
            }
        }

        function processTile(file, canvas, ctx) {
            return new Promise(resolve => {
                if (!file.type.startsWith('image/')) { resolve(); return; }
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        const rgb = getSmartAverageColor(ctx, 0, 0, canvas.width, canvas.height);
                        const lab = ColorUtils.rgbToLab(rgb.r, rgb.g, rgb.b);
                        
                        state.tiles.push({
                            id: Math.random().toString(36).substr(2, 9),
                            img: img,
                            rgb: rgb,
                            lab: lab
                        });
                        resolve();
                    };
                    img.onerror = resolve;
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function updateTileUI() {
            els.tileCount.innerText = state.tiles.length;
            els.clearTilesBtn.classList.toggle('hidden', state.tiles.length === 0);
            
            els.tileContainer.innerHTML = '';
            const recent = state.tiles.slice(-10);
            recent.forEach(t => {
                const div = document.createElement('div');
                div.className = "flex-shrink-0 w-12 h-12 rounded-lg overflow-hidden border border-gray-200 bg-gray-100 shadow-sm";
                const cl = t.img.cloneNode();
                cl.className = "w-full h-full object-cover";
                div.appendChild(cl);
                els.tileContainer.appendChild(div);
            });
        }

        function checkReady() {
            const ok = !!state.mainImage;
            els.generateBtn.disabled = !ok;
            if(ok) els.generateBtn.classList.remove('opacity-50');
        }

        // --- Zoom & Pan Logic ---

        function startPan(e) {
            if (els.canvas.classList.contains('hidden')) return;
            state.view.isDragging = true;
            state.view.lastX = e.clientX;
            state.view.lastY = e.clientY;
            els.canvasViewport.style.cursor = 'grabbing';
        }

        function movePan(e) {
            if (!state.view.isDragging) return;
            
            const dx = e.clientX - state.view.lastX;
            const dy = e.clientY - state.view.lastY;
            
            state.view.x += dx;
            state.view.y += dy;
            state.view.lastX = e.clientX;
            state.view.lastY = e.clientY;
            
            updateTransform();
        }

        function endPan() {
            state.view.isDragging = false;
            els.canvasViewport.style.cursor = 'grab';
        }

        function zoomCanvas(factor) {
            if (els.canvas.classList.contains('hidden')) return;
            const newScale = state.view.scale * factor;
            
            // Limit scale
            if (newScale < 0.05 || newScale > 20) return;
            
            state.view.scale = newScale;
            updateTransform();
        }

        function resetZoom() {
            if (els.canvas.classList.contains('hidden')) return;
            fitCanvasToViewport();
        }

        function fitCanvasToViewport() {
            const vw = els.canvasViewport.clientWidth;
            const vh = els.canvasViewport.clientHeight;
            const cw = els.canvas.width;
            const ch = els.canvas.height;
            
            if (cw === 0 || ch === 0) return;

            // Padding of 20px
            const scaleX = (vw - 40) / cw;
            const scaleY = (vh - 40) / ch;
            const scale = Math.min(scaleX, scaleY);
            
            state.view.scale = scale;
            state.view.x = 0;
            state.view.y = 0;
            
            updateTransform();
        }

        function updateTransform() {
            const { x, y, scale } = state.view;
            els.canvasTransform.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        }

        // --- Core Generation Logic ---

        async function generateMosaic() {
            if (!state.mainImage) return;
            
            setLoading(true, "モザイク構築中...", "最適なピースをマッチング中");
            els.emptyState.classList.add('hidden');
            els.zoomControls.classList.add('hidden'); // Hide controls during generation
            els.canvas.classList.add('hidden'); // Hide canvas during generation

            const mainImg = state.mainImage;
            const tilesX = state.settings.tilesX;
            const aspect = mainImg.height / mainImg.width;
            const tilesY = Math.floor(tilesX * aspect);

            // Output setup
            const canvas = els.canvas;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            const outputScale = Math.min(2400 / mainImg.width, 2.0); 
            canvas.width = mainImg.width * outputScale;
            canvas.height = mainImg.height * outputScale;
            
            const tileW = canvas.width / tilesX;
            const tileH = canvas.height / tilesY;

            // 1. Analyze Main Image
            const srcCanvas = document.createElement('canvas');
            srcCanvas.width = tilesX;
            srcCanvas.height = tilesY;
            const srcCtx = srcCanvas.getContext('2d');
            srcCtx.drawImage(mainImg, 0, 0, tilesX, tilesY);
            
            const srcData = srcCtx.getImageData(0, 0, tilesX, tilesY).data;

            // 2. Matching
            const gridMap = Array(tilesY).fill(null).map(() => Array(tilesX).fill(null));
            const totalCells = tilesX * tilesY;
            const batchSize = 50;

            const useDiversity = state.settings.diversity && state.tiles.length > 20;
            const hasTiles = state.tiles.length > 0;
            
            // Usage Tracking
            const tileUsageCount = {}; // Maps tile ID to usage count
            // Initialize usage counts
            state.tiles.forEach(t => tileUsageCount[t.id] = 0);

            for (let i = 0; i < totalCells; i++) {
                if (i % batchSize === 0) {
                    updateProgress((i / totalCells) * 90);
                    await new Promise(r => requestAnimationFrame(r));
                }

                const gx = i % tilesX;
                const gy = Math.floor(i / tilesX);

                const idx = i * 4;
                const tr = srcData[idx];
                const tg = srcData[idx+1];
                const tb = srcData[idx+2];
                const targetLab = ColorUtils.rgbToLab(tr, tg, tb);

                let bestTile = null;
                
                if (hasTiles) {
                    let minScore = Infinity;
                    
                    for (const tile of state.tiles) {
                        let score = ColorUtils.deltaE(targetLab, tile.lab);

                        // Apply Diversity Logic
                        if (useDiversity) {
                            // 1. Global Frequency Penalty (Use count penalty)
                            const count = tileUsageCount[tile.id] || 0;
                            score += count * 4.0;

                            // 2. Local Neighborhood Penalty
                            if (gx > 0 && gridMap[gy][gx-1] === tile.id) score += 100; // Left
                            if (gy > 0 && gridMap[gy-1][gx] === tile.id) score += 100; // Top
                            if (gy > 0 && gx > 0 && gridMap[gy-1][gx-1] === tile.id) score += 50; // Top-Left
                            if (gy > 0 && gx < tilesX-1 && gridMap[gy-1][gx+1] === tile.id) score += 50; // Top-Right
                        }

                        if (score < minScore) {
                            minScore = score;
                            bestTile = tile;
                        }
                    }

                    // Register usage
                    if (bestTile) {
                        gridMap[gy][gx] = bestTile.id;
                        tileUsageCount[bestTile.id]++; // Increment count
                    }
                }

                // Draw
                const dx = gx * tileW;
                const dy = gy * tileH;

                if (bestTile) {
                    ctx.drawImage(bestTile.img, dx, dy, tileW, tileH);
                    
                    if (state.settings.colorCorrect) {
                        ctx.fillStyle = `rgba(${tr},${tg},${tb}, 0.25)`;
                        ctx.fillRect(dx, dy, tileW, tileH);
                    }
                } else {
                    ctx.fillStyle = `rgb(${tr},${tg},${tb})`;
                    ctx.fillRect(dx, dy, tileW, tileH);
                }
            }

            if (state.settings.blend > 0) {
                updateProgress(95);
                ctx.save();
                ctx.globalAlpha = state.settings.blend;
                ctx.drawImage(mainImg, 0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            setLoading(false);
            els.downloadBtn.disabled = false;
            
            // Show canvas and reset zoom
            els.canvas.classList.remove('hidden');
            els.zoomControls.classList.remove('hidden');
            fitCanvasToViewport();
            
            // NEW: Auto-scroll to preview result on completion
            // Using setTimeout to ensure layout update is complete
            setTimeout(() => {
                els.canvasViewport.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
            
            // Status message update
            els.statusMessage.innerHTML = `<i data-lucide="check-circle" class="w-4 h-4 text-green-500"></i> 生成完了 (${canvas.width}x${canvas.height}px)`;
            lucide.createIcons();
        }

        // --- UI Utils ---
        function setLoading(active, text, subtext = "") {
            state.isProcessing = active;
            if(active) {
                els.loadingOverlay.classList.remove('hidden');
                els.loadingOverlay.classList.add('flex');
                els.loadingText.innerText = text;
                els.loadingSubText.innerText = subtext;
                els.progressBar.style.width = '0%';
                els.progressText.innerText = '0%';
                els.generateBtn.disabled = true;
            } else {
                els.loadingOverlay.classList.add('hidden');
                els.loadingOverlay.classList.remove('flex');
                els.generateBtn.disabled = false;
            }
        }

        function updateProgress(pct) {
            els.progressBar.style.width = `${pct}%`;
            els.progressText.innerText = `${Math.round(pct)}%`;
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = `mosaic_pro_${Date.now()}.png`;
            link.href = els.canvas.toDataURL('image/png', 0.9);
            link.click();
        }

    </script>
</body>
</html>